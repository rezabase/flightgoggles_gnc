#ifndef __FG_CONTROL_HPP__
#define __FG_CONTROL_HPP__

#include "sensor_msgs/Imu.h"


namespace flightgoggles_gnc {



  class FG_Control {
    public:

        FG_Control(void);
        ~FG_Control(void);

        void init(void); //Initiates and loads the required parameters
        void load_params(bool); //Called by init to load come parameters from the config files
        void control(void); //This is the main PID controller, called in a ros loop
        void reconfig_params_Callback(const flightgoggles_gnc::PID_gains&); //Used only during the tuning of PID gain parameters. This is Dynamic Reconfiguration related. 

        void imuCallback(const sensor_msgs::Imu::ConstPtr&); //IMU Callback. This is the noisy IMU.
        void tfCallback(const tf2_msgs::TFMessage::ConstPtr&); // TF is ground truth location and rotation. TF is published by flight_google dynamics and must be used ONLY for Testing and debugging.
        void trajectoryCallback(const flightgoggles_gnc::TrajPoint&); 


    private:        
        ros::NodeHandle n;

        // *** ROS TOPIC Publishers ***
        ros::Publisher pub_vel; //To publish collective thrust and velocity. This is what FlightGoggles originally requires.
        ros::Publisher pub_motor_thrusts; //To publish individual motors to the simulator. 

        // *** ROS Topics Subscribers ***
        ros::Subscriber sub_imu;        //Generated by the quadcopter (this is noisy)
        ros::Subscriber sub_tf;         //Ground truth position and rotation of the UAV
        ros::Subscriber sub_pid_gain_config; //ONLY used for PID tuning. To receive PID gain config parameters from ROS Dynamic Configuration
        ros::Subscriber sub_trajectory_point; //Received the next trajectory point from ROS topics. 

        TrajectoryPoint traj_point; //This is the next trajectory point that the UAV is moving to. 


        // *************** Controller Paramters that will be loaded from the control_params.yaml file ******************
        // -------------- quadcopter physical parameters --------------
        float mass = 1.0; //0.4855; //mass [kg]
        float L = 0.17;   //distance from vehicle origin to motors [m]  ###
        float Ixx = 0.0023, Iyy = 0.0023, Izz = 0.0046; // mass moment of inertia / second moment of inertia
        float kappa = 0.016; //ratio between thrust [N] and torque due to drag [N m]. torque = kappa * thrust
        float minMotorThrust = 0.1, maxMotorThrust = 4.5;

        // **** DRONE Constants to tune: 
        float kpPosXY = 50, kpPosZ = 40, KiPosZ = 40;  // Position control gains
        float kpVelXY = 20, kpVelZ = 14;  //Velocity Control Gains
        float kpBank = 13, kpYaw = 1;     //Angle control gains
        V3F kpPQR = V3F(41.5, 41.5, 6);         //Angle rate gains
  
        // limits & saturations
        float maxAscentRate = 5, maxDescentRate  =2;
        float maxSpeedXY = 5;
        float maxAccelXY;
        float maxTiltAngle = 0.7;
        // **************   END OF CONTROL PARAMTETERS ****************************************************************

        // integral control
        float integratedAltitudeError;

        // Estimated current state of the UAV 
        Quaternion<float> estAtt;
        V3F estVel;
        V3F estPos;
        V3F estOmega;

        // measurements from IMU or other sensors.
        //float optFlowX, optFlowY;
        V3F gyros;
        V3F accels;
        //float range;


        // PID Controller functions
        void Init(void);
        float AltitudeControl(float posZCmd, float velZCmd, float posZ, float velZ, Quaternion<float> attitude, float accelZCmd, float dt);
        V3F LateralPositionControl(V3F posCmd, V3F velCmd, V3F pos, V3F vel, V3F accelCmd); // returns a desired acceleration in global frame
        float YawControl(float yawCmd, float yaw); // returns desired yaw rate
        V3F BodyRateControl(V3F pqrCmd, V3F pqr); // returns desired moments
        V3F RollPitchControl(V3F accelCmd, Quaternion<float> attitude, float collThrustCmd); // returns a desired roll and pitch rate 
        void GenerateMotorCommands(float collThrustCmd, V3F momentCmd);


  };
}

#endif
